Arrays

Det går inte att sortera en array med Arrays.sort(arr) om det finns nullvärden i arrayen.

int[] arr = {1,2,3,4};
Arrays.toString(arr) // skriver ut arrayen. [1,2,3,4]
int[] arr2 = Arrays.copyOf(arr, arr.length + 1) // kopierar array och returnerar den med plats för ett till element.


----------

Metoden summaryStatistics från en stream kan ge flera värden i samma operation. T.e.x max, min, average, sum, count.
  List<Integer> list = new ArrayList<>();

    list.add(5);
    list.add(2);
    list.add(12);
    list.add(22);
    list.add(25);
    list.add(-5);
    list.add(20);

    IntSummaryStatistics stats = list.stream().mapToInt(x -> x).summaryStatistics();

----------------------

Naturligt jämförbara objekt.

Gör objekt naturligt jämförbara genom att implementera Comparable interfacen och ange klasssen som generisk typ.
Definera sedan den abstrakta metoden compareTo(<T> o) och skriv in jämförelselogiken där.

compareTo returnerar en int beroende på hur jämförelsen med andra objektet gick. 1 om större, -1 om mindre, 0 om lika.
Exempel:

public class Dice implements Comparable<Dice> {
        public int compareTo(Dice dice) {
        ... return -1;
        ... return 1;
        ... return 0;
        }
}

Man kan även använda Comparable klass som ingår i en annan klass för jämförelse.
Då måste både huvudklass och klassen som ingår i huvudklassen implementera Comparable.

Exempel

public class Roll implements Comparable<Roll> {
        private static Dice dice1 = new Dice(); // klass som ingår i huvudklassen

        public int compareTo(Dice dice2) {
            return dice1.compareTo(dice2); // anropar Dice klassens compareTo som vi definerat ovan.
        }
}

---------------------------------

Icke naturligt jämförbara objekt

En klass kan eller bör inte alltid jämföra sig själv med andra. Då behöver vi skapa en hjälpklass
som implementerar Comparator med den generiska typen som den ska jämföra.
Hjälpklassen tar in båda objekten som argument och returnerar +1 och objekt1 är störst, -1 om det är minst, och 0 om lika.

Exempel:

public class DiceComparator implements Comparator<Dice> {
        public int compare(Dice d1, Dice d2) {
            ... return -1;
            ... return 1;
            ... return 0;
        }
}

----------------------------------

Det går att använda två sätt att jämföra strängar -
1) alfabetisk - alfabetiskt ordning.

2) genom lokal känslighet (local sensitivity) - java använder språkinställningarna i datorn som exekverar koden.

Collator col = Collator.getInstance();
col.setStrength(Collator.PRIMARY);

String s1 = "a";
String s2 = "b";

Locale.setDefault(Locale.of("sv", "SE"));
col.compare(s1,s1); // jämför med lokal känslighet enligt svensk språkinställning

s1.compareTo(s2) // jämför alfabetiskt utan känslighet för lokala språkinställningar

------------------------------------

I Collections klassen så finns det en statisk metod sort(list, comp) som tar in en samling (List) och ett comparatorobjekt.
Metoden sorterar den faktiskta samlingen som referensen pekar mot, dvs inte en kopia som returneras. Denna metod skiljer
sig from stream().sorted(list, comp).collect(Arraylist::new) som returnerar en kopia.


----------------------------------