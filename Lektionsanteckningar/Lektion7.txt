Naturligt jämförbara objekt.

Gör objekt naturligt jämförbara genom att implementera Comparable interfacen och ange klasssen som generisk typ.
Definera sedan den abstrakta metoden compareTo(<T> o) och skriv in jämförelselogiken där.

compareTo returnerar en int beroende på hur jämförelsen med andra objektet gick. 1 om större, -1 om mindre, 0 om lika.
Exempel:

public class Dice implements Comparable<Dice> {
        public int compareTo(Dice dice) {
        ... return -1;
        ... return 1;
        ... return 0;
        }
}

Man kan även använda Comparable klass som ingår i en annan klass för jämförelse.
Då måste både huvudklass och klassen som ingår i huvudklassen implementera Comparable.

Exempel

public class Roll implements Comparable<Roll> {
        private static Dice dice1 = new Dice(); // klass som ingår i huvudklassen

        public int compareTo(Dice dice2) {
            return dice1.compareTo(dice2); // anropar Dice klassens compareTo som vi definerat ovan.
        }
}

---------------------------------

Icke naturligt jämförbara objekt

En klass kan eller bör inte alltid jämföra sig själv med andra. Då behöver vi skapa en hjälpklass
som implementerar Comparator med den generiska typen som den ska jämföra.
Hjälpklassen tar in båda objekten som argument och returnerar +1 och objekt1 är störst, -1 om det är minst, och 0 om lika.

Exempel:

public class DiceComparator implements Comparator<Dice> {
        public int compare(Dice d1, Dice d2) {
            ... return -1;
            ... return 1;
            ... return 0;
        }
}

----------------------------------

I Collections klassen så finns det en statisk metod sort(list, comp) som tar in en samling (List) och ett comparatorobjekt.
Metoden sorterar den faktiskta samlingen som referensen pekar mot, dvs inte en kopia som returneras. Denna metod skiljer
sig from stream().sorted(list, comp).collect(Arraylist::new) som returnerar en kopia.


----------------------------------
I Arraylist så finns det en metod subList(end, start) som returnerar en sublista av huvudlistan som anroped sker från.
Du kan ändra eller ta bort element genom clear(). Det ändra själva huvudlistan också.

Dynamisk bindning innebär att man överlagrar metoder i subklasser så att man kan anropa dem från en referens med ett
objekt som ligger högre upp i hierarkin. Detta fungera eftersom vid metodanrop så är det klassen som bestämmer vilken
metod som anropas, inte referensen.

Objekt o = new Case(); // o är referensen och Case är klassen.

Det är endast abstrakta klasser som får ha abstrakta klasser.

Nyckelordet default används inom interfaces. Det gör att man kan definera metoden i interfacen och den implementeras
by default i klassen som implementerar interfacen så länge den klassen inte redan har definerat en metod med samma
metodsignatur.
